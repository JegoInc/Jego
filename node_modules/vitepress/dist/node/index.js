import { normalizePath } from 'vite';
export { loadEnv } from 'vite';
import { n as normalizeGlob, g as glob, c as createMarkdownRenderer, p as pMap, f as fs, m as matter, a as postcssPrefixSelector } from './chunk-DjRwZkAg.js';
export { S as ScaffoldThemeType, e as build, y as createServer, i as defineAdditionalConfig, h as defineConfig, j as defineConfigWithTheme, d as defineLoader, b as defineRoutes, w as disposeMdItInstance, u as init, k as isAdditionalConfigFile, o as mergeConfig, r as resolveConfig, s as resolvePages, q as resolveSiteData, t as resolveSiteDataByRoute, l as resolveUserConfig, v as scaffold, x as serve } from './chunk-DjRwZkAg.js';
import path from 'node:path';
import 'node:crypto';
import 'node:module';
import 'node:url';
import 'node:process';
import 'node:fs/promises';
import 'node:fs';
import 'fs';
import 'node:events';
import 'node:stream';
import 'node:string_decoder';
import 'path';
import 'util';
import 'os';
import 'stream';
import 'readline';
import 'url';
import 'child_process';
import 'string_decoder';
import 'zlib';
import '@vue/shared';
import 'node:readline';
import 'node:tty';
import 'node:util';
import 'node:zlib';
import 'node:http';
import 'node:timers';
import 'node:querystring';
import 'tty';
import 'constants';
import 'assert';
import '@shikijs/transformers';
import 'shiki';
import 'minisearch';

function createContentLoader(watch, options = {}) {
  const config = global.VITEPRESS_CONFIG;
  if (!config) {
    throw new Error(
      "content loader invoked without an active vitepress process, or before vitepress config is resolved."
    );
  }
  const cache = /* @__PURE__ */ new Map();
  watch = normalizeGlob(watch, config.srcDir);
  return {
    watch,
    options: { globOptions: options.globOptions },
    async load(files) {
      files = files ?? await glob(watch, options.globOptions);
      const md = await createMarkdownRenderer(
        config.srcDir,
        config.markdown,
        config.site.base,
        config.logger
      );
      const raw = await pMap(
        files,
        async (file) => {
          if (!file.endsWith(".md")) return null;
          const timestamp = fs.statSync(file).mtimeMs;
          const cached = cache.get(file);
          if (cached && timestamp === cached.timestamp) return cached.data;
          const src = fs.readFileSync(file, "utf-8");
          const renderExcerpt = options.excerpt;
          const { data: frontmatter, excerpt } = matter(
            src,
            typeof renderExcerpt === "string" ? { excerpt_separator: renderExcerpt } : { excerpt: renderExcerpt }
            // gray-matter types are wrong
          );
          const url = "/" + normalizePath(path.relative(config.srcDir, file)).replace(/(^|\/)index\.md$/, "$1").replace(/\.md$/, config.cleanUrls ? "" : ".html");
          const html = options.render ? await md.renderAsync(src) : void 0;
          const renderedExcerpt = renderExcerpt ? excerpt && await md.renderAsync(excerpt) : void 0;
          const data = {
            src: options.includeSrc ? src : void 0,
            html,
            frontmatter,
            excerpt: renderedExcerpt,
            url
          };
          cache.set(file, { data, timestamp });
          return data;
        },
        { concurrency: config.buildConcurrency }
      );
      const filtered = raw.filter((i) => i !== null);
      return options.transform?.(filtered) ?? filtered;
    }
  };
}

function postcssIsolateStyles(options = {}) {
  return postcssPrefixSelector({
    prefix: ":not(:where(.vp-raw, .vp-raw *))",
    includeFiles: [/base\.css/],
    transform(prefix, _selector) {
      const [selector, pseudo] = splitSelectorPseudo(_selector);
      return selector + prefix + pseudo;
    },
    ...options
  });
}
function splitSelectorPseudo(selector) {
  const [base, pseudo = ""] = selector.split(/(?<!\\)(:\S*)$/);
  return [base, pseudo];
}

export { createContentLoader, createMarkdownRenderer, postcssIsolateStyles, splitSelectorPseudo };
